<meta name="color-scheme" content="dark">

<style> * {font-family: monospace;}</style>
<h1>CHESS</h1>
<h2 id="info1">Welcome to Chess. White is lowercase and black is uppercase. <br></h2>
<h3 id="squareNames"><br></h3>
<h3 id="info2">Press to start the game</h3>
<input id="output" type="text"> <br>
<button id="startButton">Start Game</button>
<button id="restartButton">Restart Game</button>
<button id="pieceButton">Confirm Piece</button>
<button id="squareButton">Confirm Square</button>
<button id="upgradeButton">Confirm Choice</button>
<button id="castlingYesButton">Yes</button>
<button id="castlingNoButton">No</button>
<button id="castlingWr1Button">r1</button>
<button id="castlingWr2Button">r2</button>
<button id="castlingBr1Button">R1</button>
<button id="castlingBr2Button">R2</button>

<script>
    //HTML-ELEMENTS//
//This button starts the game
var startButton = document.getElementById("startButton");
startButton.addEventListener("click", TurnOrder);
//This button restarts the game when a game is over
var restartButton = document.getElementById("restartButton");
restartButton.addEventListener("click", TurnOrder);
restartButton.style.display = "none";
//This button confirms the piece choice
var pieceButton = document.getElementById("pieceButton");
pieceButton.addEventListener("click", PieceChooser); 
pieceButton.style.display = "none";
//This button confirms the square choice.
var squareButton = document.getElementById("squareButton");
squareButton.addEventListener("click", SquareChooser);
squareButton.style.display = "none";
//This button confirms the upgrade choice
var upgradeButton = document.getElementById("upgradeButton");
upgradeButton.addEventListener("click", UpgradePiece);
upgradeButton.style.display = "none";
//These buttons controls the castling outputs
var castlingYesButton = document.getElementById("castlingYesButton");
castlingYesButton.addEventListener("click", ShowCastlingButtons);
castlingYesButton.style.display = "none";
var castlingNoButton = document.getElementById("castlingNoButton");
castlingNoButton.addEventListener("click", PieceInput);
castlingNoButton.style.display = "none";
var castlingWr1Button = document.getElementById("castlingWr1Button");
castlingWr1Button.addEventListener("click", Wr1Castling);
castlingWr1Button.style.display = "none";
var castlingWr2Button = document.getElementById("castlingWr2Button");
castlingWr2Button.addEventListener("click", Wr2Castling);
castlingWr2Button.style.display = "none";
var castlingBr1Button = document.getElementById("castlingBr1Button");
castlingBr1Button.addEventListener("click", Br1Castling);
castlingBr1Button.style.display = "none";
var castlingBr2Button = document.getElementById("castlingBr2Button");
castlingBr2Button.style.display = "none";
castlingBr2Button.addEventListener("click", Br2Castling);


//Gives information about what players turn it is and what color is upper- and lowercase. 
//Also alerts the player about check and mate
var infoText1 = document.getElementById("info1");
//Gives information about what the players should write in the text box and if the player writes an invalid input
var infoText2 = document.getElementById("info2");

//A textbox where the players can write what piece they want to move and where they want to move it
var output = document.getElementById("output");
output.style.display = "none";

    //ARRAYS//
//Stores the opening board. Capital letter stands for black and lowercase stands for white. [] is an empty square.
var chessBoard = [
    "R1", "N1", "B1", "Q1", "KI", "B2", "N2", "R2",
    "P1", "P2", "P3", "P4", "P5", "P6", "P7", "P8",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8",
    "r1", "n1", "b1", "q1", "ki", "b2", "n2", "r2"
]; 

//Stores the name of the squares.
var squareNames = [
    "A8", "B8" ,"C8", "D8", "E8", "F8", "G8", "H8",
    "A7", "B7" ,"C7", "D7", "E7", "F7", "G7", "H7",
    "A6", "B6" ,"C6", "D6", "E6", "F6", "G6", "H6",
    "A5", "B5" ,"C5", "D5", "E5", "F5", "G5", "H5",
    "A4", "B4" ,"C4", "D4", "E4", "F4", "G4", "H4",
    "A3", "B3" ,"C3", "D3", "E3", "F3", "G3", "H3",
    "A2", "B2" ,"C2", "D2", "E2", "F2", "G2", "H2",
    "A1", "B1" ,"C1", "D1", "E1", "F1", "G1", "H1"
]; 

//Is used when checking for check.
//For every possible enemy move, the array is updated accordingly and then reseted to be the same as chessBoard
var checkStorage = [
    "R1", "N1", "B1", "Q1", "KI", "B2", "N2", "R2",
    "P1", "P2", "P3", "P4", "P5", "P6", "P7", "P8",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8",
    "r1", "n1", "b1", "q1", "ki", "b2", "n2", "r2"
];

//Stores all unmoved pawns, so the program knows which ones that can move 2 squares.
var unmovedPawns = ["p1", "p2", "p3", "p4", "p5","p6", "p7", "p8", "P1", "P2", "P3", "P4", "P5", "P6", "P7", "P8"];
//Stores the unmoved kings and rooks, so the program knows which ones that can perform the castling mechanic
var unmovedCastling = ["ki", "r1", "r2", "KI", "R1", "R2"];

//Stores all the white and black pieces.
//Is used with the enemyPieces and friendlyPieces variables, for the program to know what the enemy and friendly pieces are
//When a piece is taken it gets removed from its array.
var whitePieces = ["p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "r1", "r2", "b1", "b2", "n1", "n2", "q1", "ki"];
var blackPieces = ["P1", "P2", "P3", "P4", "P5", "P6", "P7", "P8", "R1", "R2", "B1", "B2", "N1", "N2", "Q1", "KI"];

//Stores all the pieces which the pawns can be upgraded to
var upgradePieces = ["r", "b", "n", "q","R", "B", "N", "Q"];
//Is used when calculating what number to add after the upgraded piece
var upgradeStorage = [];
//These arrays is the same as whitePieces and blackPieces but never changes to work with the upgrade mechanics
var upgradeWhitePieces = ["p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "r1", "r2", "b1", "b2", "n1", "n2", "q1", "ki"];
var upgradeBlackPieces = ["P1", "P2", "P3", "P4", "P5", "P6", "P7", "P8", "R1", "R2", "B1", "B2", "N1", "N2", "Q1", "KI"];

//Stores what pawns that can make en passant
var enPassantPieces = [];
//Stores all the squares which a piece can move to
var legalMoves = [];
//Stores the squares where the king would be in check
var checkSquares = [];

    //VARIABLES//
//Variables for the chosen piece and square to move to.
var chosenPiece;
var chosenSquare;
//Variable for the index of where the chosenPiece were
var pieceIndex;
//Variable for the index of where the chosenPiece is being moved
var squareIndex;
//A variable for when calculating if en passant is possible
var ePIndex;
//Variables to determine what color is friendly and enemy
var enemyPieces;
var friendlyPieces;
//Is used when upgrading. Is either upgradeWhitePieces or upgradeBlackPieces
var upgradeFriendlyPieces;
//Is used when calculating check. Instead of chosenPiece
var kingSlayer;
//This variable makes sure that the EnPassant functions is not runned at the start of the game, when chosenPiece is not declared
var startGame = false;

    //SPECIAL MOVES VARIABLES//
//These variables are used when checking what rooks can perform castling
var isCastlingWr1 = false;
var isCastlingWr2 = false;
var isCastlingBr1 = false;
var isCastlingBr2 = false;
//A variable that stores what square a pawn is moved to when performing an en passant

var enPassantSquare;
//A variable that decides what piece a pawn is being upgraded to
var upgradeToPiece;

    //TURN ORDER & CHECK VARIABLES//
//Checks which players turn it is.
var isWhiteTurn = true; 
//Decides if a player are in check
var isCheck = false;
var isCheckingForCheck = false;
var wouldBeCheck = false;
//Decides if a player are mate and looses the game
var isMate = false;
//Is used when checking for mate. 
//Makes sure so the NoLegalMoves function is not runned when going through the MovementManager
var checkingForMate = false;

//Prints the board so it is visible befor the game starts
PrintBoard();

//This function is what prints the board.
function PrintBoard()
{
    //Stores the squareNames HTML-text into a variable so it can be updated
    var updateBoard = document.getElementById("squareNames");
    //Clears the squareNames HTML-text so that there is not multible boards printed
    updateBoard.innerHTML = " ";   
    //Updates the squareNames HTML-text to be the same as the chessBoard array
    for(var i = 0; i < chessBoard.length; i++)
    { 
        if((i + 1) % 8 === 0) //Checks if the index + 1 of chessBoard is divisble by 8
        {
            //When reaching the end of the board a new row is being created
            var updateBoard = document.getElementById("squareNames");
            updateBoard.innerHTML += chessBoard[i] + " " + "<br>";
        }
        else
        {
            //Else the next square is being added
            var updateBoard = document.getElementById("squareNames");
            updateBoard.innerHTML += chessBoard[i] + " ";
        }
    }
}

//This function controls the actual turns.
function TurnOrder()
{
    //Hides the following buttons
    startButton.style.display = "none";
    restartButton.style.display = "none";
    squareButton.style.display = "none";
    upgradeButton.style.display = "none";
    //This is used when someone has won the game and the restart button is being pressed
    //PrintBoard() prints chessBoard which has been reseted inside GameOver()
    if(isMate)
    {
        PrintBoard();
        isMate = false;
    }

    //Declares enemyPieces and friendlyPieces depending on what players turn it is
    if(isWhiteTurn)
    {
        enemyPieces = blackPieces;
        friendlyPieces = whitePieces;
    }
    else
    {
        enemyPieces = whitePieces;
        friendlyPieces = blackPieces;
    }

    //If it is not the first turn, and the piece the enemy moved was a pawn,
    //EnPassantFunction() is being runned here so pieceIndex has been declared
    if(startGame)
    {
        if(chosenPiece.includes("p") || chosenPiece.includes("P"))
        {
            EnPassantFunction();
        }
    }
    else
    {
        startGame = true;
    }
    
    //Checks if a player can perform a castling move
    CastlingChecker();
    //Checks if the player is in check or not
    //isCheckingForCheck is used so the program knows if it should check if a player IS in check
    //or if a player WOULD BE in check if a piece is moved
    isCheckingForCheck = true;
    EnemyCheckChecker();
    isCheckingForCheck = false;

    //Checks if a player are in check or mate and updates infoText1 accordingly
    if(isCheck)
    {
        if(isWhiteTurn)
        {
            MateChecker();
            if(isMate)
            {
                infoText1.innerHTML = "Checkmate! Black wins!"; 
                GameOver();  
            }
            else
            {
                PlayerTurn();
            }
        }
        else
        {
            MateChecker();
            if(isMate)
            {
                infoText1.innerHTML = "Checkmate! White wins!"; 
                GameOver();  
            }
            else
            {
                PlayerTurn();
            }
        }    
    }
    else
    {
        PlayerTurn();
    }
}

//Checks if a player is in check or not and updates infoText1 accordingly
function PlayerTurn()
{
    if(isCheck)
    {
        if(isWhiteTurn)
        {
            infoText1.innerHTML = "White turn - Check!"; 
        }
        else
        {
            infoText1.innerHTML = "Black turn - Check!"; 
        }
    }
    else
    {
        //Notifies which players turn it is.
        if(isWhiteTurn)
        {
            infoText1.innerHTML = "White turn"; 
        }
        else
        {
            infoText1.innerHTML = "Black turn";
        }  
    }

    //Checks if any of the castling pieces can perform a castling and goes to either
    //CastlingRequest() or PieceInput()
    if(isCastlingWr1 === true || isCastlingWr2 === true || isCastlingBr1 === true || isCastlingBr2 === true)
    {
        CastlingRequest();
    } 
    else
    {
        PieceInput();
    }
}

    //PIECE CHOICE FUNCTIONS//
//Asks the player what piece they want to move
function PieceInput()
{
    infoText2.innerHTML = "What piece do you want to move?";
    
    castlingYesButton.style.display = "none";
    castlingNoButton.style.display = "none";
    pieceButton.style.display = "block";
    output.style.display = "block";
    //Clears the textbox
    output.value = "";

    //Turns all isCastling variables to false, incase the player chooses NO on the question to castling
    isCastlingWr1 = false;
    isCastlingWr2 = false;
    isCastlingBr1 = false;
    isCastlingBr2 = false;
}

function PieceChooser()
{
    chosenPiece = output.value;
    //Depending on what players turn it is, the program makes chosenPiece into lower or upper case
    if(isWhiteTurn)
    {
        chosenPiece = chosenPiece.toLowerCase();
    }
    else
    {
        chosenPiece = chosenPiece.toUpperCase();
    } 
    //If the player chooses a piece that is not part of friendlyPieces (blackPieces/whitePieces)
    //the program goes to InvalidPieces() otherwise MovementManager()
    if(!friendlyPieces.includes(chosenPiece))
    {  
        InvalidPiece();
    }
    else
    {
        MovementManager();
    }
}

function InvalidPiece()
{
    infoText2.innerHTML = "That is not a valid piece!";
}

//If the player chooses a piece that cannot be moved infoText1 is being updated, else it continues to SquareInput()
function NoLegalMoves()
{
    if(legalMoves.length === 0)
    {
        infoText2.innerHTML = "You can not move that piece this turn!";  
    }
    else
    {
        SquareInput();
    } 
}

//Asks the player what square they want to move the chosen piece
function SquareInput()
{
    pieceButton.style.display = "none";
    squareButton.style.display = "block";
    infoText2.innerHTML = "Where do you want to move the piece?";
    //Clears the textbox
    output.value = "";
    console.log(legalMoves);
}

function SquareChooser()
{
    //Updates the chosenSquare variable depending on the players answer.
    chosenSquare = output.value;
    chosenSquare = chosenSquare.toUpperCase();

    //If the move is legal, the board will update. Else it will go to InvalidSquare()
    if(legalMoves.includes(chosenSquare))
    {
        //Goes to RemovePieces to see if an enemy piece was taken
        RemovePieces();
        //Gets the indexes of the chosen piece and square so we can change those places in the chessBoard array. 
        pieceIndex = chessBoard.indexOf(chosenPiece);
        squareIndex = squareNames.indexOf(chosenSquare);
        chessBoard[pieceIndex] = "[]";
        chessBoard[squareIndex] = chosenPiece;
        checkStorage[pieceIndex] = "[]";
        checkStorage[squareIndex] = chosenPiece;

        //If a player has performed en passant, this removes the enemy piece that was taken
        if(chosenSquare === enPassantSquare)
        {
            if(isWhiteTurn)
            {
                chessBoard[squareIndex+8] = "[]";
            }
            else
            {
                chessBoard[squareIndex-8] = "[]";
            }
        }

        //Prints the board before going to CheckForUpgrade to enhance the visual experience
        PrintBoard();
        //The CheckForUpgrade function checks if the piece should be upgraded
        CheckForUpgrade();
    }
    else
    { 
        InvalidSquare();
    }
}

function InvalidSquare()
{
    infoText2.innerHTML = "That is not a valid move";
}

function EndTurn()
{
    //Checks if a moved pawn is in the unmovedPawns array and if it is, it gets removed
    if(unmovedPawns.includes(chosenPiece))
    {
        //Removes the chosen pawn from the unmovedPawns array.
        unmovedPawns.splice(unmovedPawns.indexOf(chosenPiece), 1);
    }

    //Resets the legalMoves properties.
    legalMoves.splice(0); 

    //Changes what players turn it is
    if(isWhiteTurn)
    {
        isWhiteTurn = false;
    }
    else
    {
        isWhiteTurn = true;
    }
    //Resets wouldBeCheck so no bugs appear during the next players turn
    wouldBeCheck = false;
    enPassantSquare = "";

    //Hides the castling buttons, then update the board, then back to TurnOrder()
    HideCastlingButtons();
    PrintBoard();
    TurnOrder();
}

//If an enemy piece was taken that piece is removed from enemyPieces (blackPieces/whitePieces)
function RemovePieces()
{
    var removePiece = chessBoard[squareNames.indexOf(chosenSquare)];
    var removeIndex = enemyPieces.indexOf(removePiece);
    if(enemyPieces.includes(removePiece))
    {
        enemyPieces.splice(removeIndex, 1);
    }
}

    //CASTLING FUNCTIONS//
function CastlingChecker()
{
    //Runs EnemyCheckChecker to see if the king would be in check on one of the squares involved in the castling move
    EnemyCheckChecker();
  
    //Depending on which players turn it is, these castling variables gets declared accordingly
    if(isWhiteTurn)
    {
        var iCastlingKi = chessBoard.indexOf("ki"); 
        var castlingKi = "ki";
        var castlingR1 = "r1";
        var castlingR2 = "r2";
    }
    else
    {
        var iCastlingKi = chessBoard.indexOf("KI");
        var castlingKi = "KI";
        var castlingR1 = "R1";
        var castlingR2 = "R2";
    }
    
    if(unmovedCastling.includes(castlingKi) && unmovedCastling.includes(castlingR1))
    {
        //Checks if castling is possible with r1/R1
        if(chessBoard[iCastlingKi-1] === "[]" && chessBoard[iCastlingKi-2] === "[]" && chessBoard[iCastlingKi-3] === "[]" && chessBoard[iCastlingKi-4] === castlingR1 && !checkSquares.includes(squareNames[iCastlingKi-1]) && 
        !checkSquares.includes(squareNames[iCastlingKi-2]) && !checkSquares.includes(squareNames[iCastlingKi-3]) && !checkSquares.includes(squareNames[iCastlingKi-4]))
        {
            if(isWhiteTurn)
            {
                isCastlingWr1 = true;
            }
            else
            {
                isCastlingBr1 = true;
            }
            //To be sure legalMoves isn't empty this gets pushed
            legalMoves.push("Castling");
        }
    }

    if(unmovedCastling.includes(castlingKi) && unmovedCastling.includes(castlingR2))
    {
        //Checks if castling is possible with r2/R2
        if(chessBoard[iCastlingKi+1] === "[]" && chessBoard[iCastlingKi+2] === "[]" && chessBoard[iCastlingKi+3] === castlingR2 && !checkSquares.includes(squareNames[iCastlingKi+1]) && 
        !checkSquares.includes(squareNames[iCastlingKi+2]) && !checkSquares.includes(squareNames[iCastlingKi+3]))
        {
            if(isWhiteTurn)
            {
                isCastlingWr2 = true;
            }
            else
            {
                isCastlingBr2 = true;
            }
            legalMoves.push("Castling");
        }
    }        
}

//Asks the player if they want to perform a castling move
function CastlingRequest()
{
    //Updates the chosenPiece variable depending on the players answer.
    infoText2.innerHTML = "Do you want to Castling?";
    pieceButton.style.display = "none";
    output.style.display = "none";
    castlingYesButton.style.display = "block";
    castlingNoButton.style.display = "block";
}

//If the player presses yes the program will show the relevant buttons
function ShowCastlingButtons()
{
    castlingYesButton.style.display = "none";
    castlingNoButton.style.display = "none"; 

    if(isCastlingWr1)
    {
        isCastlingWr1 = false;
        castlingWr1Button.style.display = "block";
    }

    if(isCastlingWr2)
    {
        isCastlingWr2 = false;
        castlingWr2Button.style.display = "block";
    }

    if(isCastlingBr1)
    {
        isCastlingBr1 = false;
        castlingBr1Button.style.display = "block";
    }

    if(isCastlingBr2)
    {
        isCastlingBr2 = false;
        castlingBr2Button.style.display = "block";
    }
}

//These 4 functions updates the board when performing caslting
function Wr1Castling()
{
    chessBoard[60] = "[]";
    chessBoard[59] = "r1";
    chessBoard[58] = "ki";
    chessBoard[56] = "[]";

    unmovedCastling.splice(unmovedCastling.indexOf("r1"), 1);
    unmovedCastling.splice(unmovedCastling.indexOf("ki"), 1);

    EndTurn();
}

function Wr2Castling()
{
    chessBoard[60] = "[]";
    chessBoard[61] = "r2";
    chessBoard[62] = "ki";
    chessBoard[63] = "[]";

    unmovedCastling.splice(unmovedCastling.indexOf("r2"), 1);
    unmovedCastling.splice(unmovedCastling.indexOf("ki"), 1);

    EndTurn();
}

function Br1Castling()
{
    chessBoard[4] = "[]";
    chessBoard[3] = "R1";
    chessBoard[2] = "KI";
    chessBoard[0] = "[]";

    unmovedCastling.splice(unmovedCastling.indexOf("R1"), 1);
    unmovedCastling.splice(unmovedCastling.indexOf("KI"), 1);

    EndTurn();
}

function Br2Castling()
{
    chessBoard[4] = "[]";
    chessBoard[5] = "R1";
    chessBoard[6] = "KI";
    chessBoard[7] = "[]";

    unmovedCastling.splice(unmovedCastling.indexOf("R2"), 1);
    unmovedCastling.splice(unmovedCastling.indexOf("KI"), 1);

    EndTurn();
}

//Hides the castling buttons
function HideCastlingButtons()
{
    castlingWr1Button.style.display = "none";
    castlingWr2Button.style.display = "none";
    castlingBr1Button.style.display = "none";
    castlingBr2Button.style.display = "none";
}

    //UPGRADE FUNCTIONS//
//This function upgrades the pawns into the chosen piece when reaching the end of the board
function CheckForUpgrade()
{
    //Checks if the chosenPiece includes p or P
    //and if the pawn has reached the top row (index <= 7) or the bottom row (index >= 56)
    if((chosenPiece.includes("p") || chosenPiece.includes("P")) && (chessBoard.indexOf(chosenPiece) <= 7 || chessBoard.indexOf(chosenPiece) >= 56))
    {
        upgradeButton.style.display = "block"; 
        squareButton.style.display = "none";
        infoText2.innerHTML = "What piece do you want to upgrade the pawn to?";    
    }
    else
    {
        EndTurn();
    }
}

//If an upgrade can be made, this function is being runned when the player presses the upgradeButton
function UpgradePiece()
{
    upgradeToPiece = output.value;

    //If the player write something that is not included in upgradePieces InvalidPiece() is runned
    if(!upgradePieces.includes(upgradeToPiece))
    {
        InvalidPiece();
    }
    else
    {
        //Checks if it is a white or a black piece
        if(chosenPiece.includes("p"))
        {
            upgradeToPiece = upgradeToPiece.toLowerCase();  
        } 
        else if(chosenPiece.includes("P"))
        {
            upgradeToPiece = upgradeToPiece.toUpperCase(); 
        } 

        //Runs UpgradeChecker() to see what number to put after the upgraded piece
        UpgradeChecker();
        chessBoard[chessBoard.indexOf(chosenPiece)] = upgradeToPiece;
        friendlyPieces.push(upgradeToPiece);
        friendlyPieces.splice(friendlyPieces.indexOf(chosenPiece), 1);

        EndTurn();
    }
}

function UpgradeChecker()
{
    if(isWhiteTurn)
    {
        upgradeFriendlyPieces = upgradeWhitePieces;
    }
    else
    {
        upgradeFriendlyPieces = upgradeBlackPieces;
    }
    //Goes through all the friendly pieces and adds all that is the same type as the upgrade choice to upgradeStorage
    for(var uI = 0; uI < upgradeFriendlyPieces.length; uI++)
    {
        if(upgradeFriendlyPieces[uI].includes(upgradeToPiece))
        {
            upgradeStorage.push(upgradeFriendlyPieces[uI]);
        }
    }

    //The length of upgradeStorage + 1 is added as the number after the upgraded piece
    upgradeToPiece = upgradeToPiece + (upgradeStorage.length + 1);
    upgradeStorage.splice(0);
}
//FORTSÄTT KOMMENTERA HÄR
    //EN PASSANT FUNCTIONS//
//This is called in TurnOrder to see if the last player moved a pawn two steps
//If that pawn ended next to an enemy pawn the enPassantSquare is being pushed into legalmoves
function EnPassantFunction()
{
    if(isWhiteTurn)
    {
        //Checks if the white player moved the pawn two steps past the enPassantSquare
        //wich is declared in PawnMovement()
        if(pieceIndex + 8 === squareNames.indexOf(enPassantSquare))
        {
            //These checks if the last players pawn ended up next to a pawn of the current player
            //piexeIndex is where the pawn was befor it moved
            ePIndex = pieceIndex+17;
            if(chessBoard[ePIndex].includes("p"))
            { //Pushing the enpassantSquare into legal moves and the pawns that can perform en passant into enPassantPieces
                legalMoves.push(enPassantSquare);
                enPassantPieces.push(chessBoard[ePIndex]);
            }
            ePIndex = pieceIndex+15;
            if(chessBoard[ePIndex].includes("p"))
            {
                legalMoves.push(enPassantSquare);
                enPassantPieces.push(chessBoard[ePIndex]);
            }
        }
    }
    else
    {
        //Checks if the black player moved the pawn two steps past the enPassantSquare
        //wich is declared in PawnMovement()
        if(pieceIndex - 8 === squareNames.indexOf(enPassantSquare))
        {
            ePIndex = pieceIndex-17;
            if(chessBoard[ePIndex].includes("P"))
            {
                legalMoves.push(enPassantSquare);
                enPassantPieces.push(chessBoard[ePIndex]);
            }
            ePIndex = pieceIndex-15;
            if(chessBoard[ePIndex].includes("P"))
            {
                legalMoves.push(enPassantSquare);
                enPassantPieces.push(chessBoard[ePIndex]);
            }
        }
    }
}

//A function that empties legalMoves and enPassantPieces if the player doesn't move an "en passant"-pawn
function ResetEnPassant()
{
    legalMoves.splice(0); 
    enPassantPieces.splice(0);
}

    //MOVEMENT FUNCTIONS//
//Depending on the players answer in PieceInput(), the program will go to the right function
function MovementManager()
{
    if(chosenPiece.includes("p") || chosenPiece.includes("P") )
    {
        //When checking for mate, MovementManager() is being called but then ResetEnPassant() and NoLegalMoves() shouldn't be called
        if(!checkingForMate)
        {
            //If the player moves a pawn that cannot perform en passant, ResetEnPassant() is being runned
            if(!enPassantPieces.includes(chosenPiece))
            {
                ResetEnPassant(); 
            }
        }
        PawnMovement(); 
        if(!checkingForMate)
        {
            //This function checks if the chosen piece can move this turn
            NoLegalMoves();       
        }
    }
    else if(chosenPiece.includes("r") || chosenPiece.includes("R"))
    {
        if(!checkingForMate)
        {  
            ResetEnPassant();
        }
        RookMovement();
        if(!checkingForMate)
        {
            NoLegalMoves();       
        }
    }
    else if(chosenPiece.includes("n") || chosenPiece.includes("N"))
    {
        if(!checkingForMate)
        {  
            ResetEnPassant();
        }
        KnightMovement();
        if(!checkingForMate)
        {
            NoLegalMoves();       
        }
    }
    else if(chosenPiece.includes("b") || chosenPiece.includes("B"))
    {
        if(!checkingForMate)
        {  
            ResetEnPassant();
        }
        BishopMovement();
        if(!checkingForMate)
        {
            NoLegalMoves();       
        }
    }
    else if(chosenPiece.includes("k")|| chosenPiece.includes("K"))
    {
        if(!checkingForMate)
        {  
            ResetEnPassant();
        }
        KingMovement();
        if(!checkingForMate)
        {
            NoLegalMoves();       
        }
    }
    else if(chosenPiece.includes("q") || chosenPiece.includes("Q"))
    {
        if(!checkingForMate)
        {  
            ResetEnPassant();
        }
        QueenMovement();
        if(!checkingForMate)
        {
            NoLegalMoves();       
        }
    }
    else
    {
        InvalidPiece();
    }
}

//Controls the pawn movement.
//Depending on which players turn it is there will be a different equation.
function PawnMovement()
{
    //A variable that keeps track of the index of all the possible moves
    var possibleMoves = chessBoard.indexOf(chosenPiece);
    if(isWhiteTurn)
    {
        //This checks if the pawn can move one step
        if(chessBoard[possibleMoves-8] === "[]")
        {
            //Changes checkStorage and then calls EnemyCheckChecker() to check if the player would be in check if this move is done
            checkStorage[possibleMoves] = "[]";
            checkStorage[possibleMoves-8] = chosenPiece;
            EnemyCheckChecker(); 

            //If the player wouldn't be in check when doing the move, the square is pushed into legalMoves
            if(!wouldBeCheck)
            {
                legalMoves.push(squareNames[possibleMoves-8]);
            }
            else //Resets wouldBeCheck so it is false again when moving on to the next possible move
            {
                wouldBeCheck = false;
            }   
            //Resets checkStorge so it is the same as chessBoard again
            checkStorage[possibleMoves] = chosenPiece;
            checkStorage[possibleMoves-8] = chessBoard[possibleMoves-8];  
        }
        
        //This checks if the pawn can move two steps
        if(unmovedPawns.includes(chosenPiece) && chessBoard[possibleMoves-16] === "[]" && chessBoard[possibleMoves-8] === "[]")
        {
            checkStorage[possibleMoves] = "[]";
            checkStorage[possibleMoves-16] = chosenPiece;
            EnemyCheckChecker(); 

            if(!wouldBeCheck)
            {
                legalMoves.push(squareNames[possibleMoves-16]);
                //If the pawn can move two steps, the enPassantSquare is declared here
                //to be used later on the next players turn when checking if en passant is possible
                enPassantSquare = squareNames[possibleMoves-8];
            }
            else
            {
                wouldBeCheck = false;
            }
            checkStorage[possibleMoves] = chosenPiece;
            checkStorage[possibleMoves-16] = chessBoard[possibleMoves-16];
        }

        //Checks if there is a black piece UP diagonaly to the RIGHT of the pawn
        //and thus if the pawn can move diagonally
        if(blackPieces.includes(chessBoard[possibleMoves-7]))
        {
            //If the chosen pawn isn't on the H-row, which all squares plus one devisible by 8 is, 
            //the square should be added to the legalMoves array 
            if((possibleMoves + 1) % 8 !== 0)
            {
                checkStorage[possibleMoves] = "[]";
                checkStorage[possibleMoves-7] = chosenPiece;
                EnemyCheckChecker(); 

                if(!wouldBeCheck)
                {
                    legalMoves.push(squareNames[possibleMoves-7]);
                }
                else
                {
                    wouldBeCheck = false;
                }
                checkStorage[possibleMoves] = chosenPiece;
                checkStorage[possibleMoves-7] = chessBoard[possibleMoves-7];
            }  
        }
        //Checks if there is a black piece UP diagonally to the LEFT of the pawn
        //and thus if the pawn can move diagonally
        if(blackPieces.includes(chessBoard[possibleMoves-9]))
        {
            //If the chosen pawn isn't on the A-row, which all squares devisble by 8 is,
            //the square should be added to the legalMoves array
            if((possibleMoves) % 8 !== 0) //(We don't need to check if it is on index 0 since it will be upgraded)
            {
                checkStorage[possibleMoves] = "[]";
                checkStorage[possibleMoves-9] = chosenPiece;
                EnemyCheckChecker(); 

                if(!wouldBeCheck)
                {
                    legalMoves.push(squareNames[possibleMoves-9]);
                }
                else
                {
                    wouldBeCheck = false;
                }
                checkStorage[possibleMoves] = chosenPiece;
                checkStorage[possibleMoves-9] = chessBoard[possibleMoves-9];
            } 
        }
    }
    else //Black
    {
        //Checks if the pawn can move one step
        if(chessBoard[possibleMoves+8] === "[]")
        {
            checkStorage[possibleMoves] = "[]";
            checkStorage[possibleMoves+8] = chosenPiece;
            EnemyCheckChecker(); 

            if(!wouldBeCheck)
            {
                legalMoves.push(squareNames[possibleMoves+8]);
            }
            else
            {
                wouldBeCheck = false;
            }
            checkStorage[possibleMoves] = chosenPiece;
            checkStorage[possibleMoves+8] = chessBoard[possibleMoves+8];
        }
        //Checks if the pawn can move two steps
        if(unmovedPawns.includes(chosenPiece) && chessBoard[possibleMoves+16] === "[]" && chessBoard[possibleMoves+8] === "[]")
        {
            checkStorage[possibleMoves] = "[]";
            checkStorage[possibleMoves+16] = chosenPiece;
            EnemyCheckChecker(); 
            
            if(!wouldBeCheck)
            {
                legalMoves.push(squareNames[possibleMoves+16]);
                enPassantSquare = squareNames[possibleMoves+8];
            }
            else
            {
                wouldBeCheck = false;
            }
            checkStorage[possibleMoves] = chosenPiece;
            checkStorage[possibleMoves+16] = chessBoard[possibleMoves+16];
        }

        //Checks if there is a piece DOWN diagonaly to the LEFT of the pawn
        //and thus if the pawn can move diagonally
        if(whitePieces.includes(chessBoard[possibleMoves+7]))
        { 
            if((possibleMoves) % 8 !== 0)
            {
                checkStorage[possibleMoves] = "[]";
                checkStorage[possibleMoves+7] = chosenPiece;
                EnemyCheckChecker(); 
                
                if(!wouldBeCheck)
                {
                    legalMoves.push(squareNames[possibleMoves+7]);
                }
                else
                {
                    wouldBeCheck = false;
                }
                checkStorage[possibleMoves] = chosenPiece;
                checkStorage[possibleMoves+7] = chessBoard[possibleMoves+7];
            }  
        }
        //Checks if there is a piece DOWN diagonally to the RIGHT of the pawn
        //and thus if the pawn can move diagonally
        if(whitePieces.includes(chessBoard[possibleMoves+9]))
        {
            if((possibleMoves+1) % 8 !== 0)
            {
                checkStorage[possibleMoves] = "[]";
                checkStorage[possibleMoves+9] = chosenPiece;
                EnemyCheckChecker(); 
                
                if(!wouldBeCheck)
                {
                    legalMoves.push(squareNames[possibleMoves+9]);
                }
                else
                {
                    wouldBeCheck = false;
                }
                checkStorage[possibleMoves] = chosenPiece;
                checkStorage[possibleMoves+9] = chessBoard[possibleMoves+9];
            } 
        }
    }
}

function RookMovement()
{    
    var possibleMoves = chessBoard.indexOf(chosenPiece);    
    //Checks if the ROOK can move to the RIGHT
    if((possibleMoves + 1) % 8 !== 0 && !friendlyPieces.includes(chessBoard[possibleMoves+1]))
    { 
        checkStorage[possibleMoves] = "[]";
        checkStorage[possibleMoves+1] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {   //The loop stops when reaching the H-row or if next square contains a friendly piece
            while((possibleMoves + 1) % 8 !== 0 && !friendlyPieces.includes(chessBoard[possibleMoves+1]))
            {
                //If the next square contains an enemy piece that square is being added to legalMoves,
                //and the loop stops
                if(enemyPieces.includes(chessBoard[possibleMoves+1]))
                {
                    possibleMoves++;
                    legalMoves.push(squareNames[possibleMoves]);
                    break;
                }
                possibleMoves++;
                legalMoves.push(squareNames[possibleMoves]);
            }
        }
        else
        {
            wouldBeCheck = false;
        }
        possibleMoves = chessBoard.indexOf(chosenPiece);
        checkStorage[possibleMoves] = chosenPiece;
        checkStorage[possibleMoves+1] = chessBoard[possibleMoves+1];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the ROOK can move to the LEFT
    //If it's not on the A-row or there's a friendly piece next to it
    //Since 0 isn't devisible by 0 we also have to check if it is on A1 (index 0)
    if(possibleMoves % 8 !== 0 && possibleMoves !== 0 && !friendlyPieces.includes(chessBoard[possibleMoves-1]))
    {
        checkStorage[possibleMoves] = "[]";
        checkStorage[possibleMoves-1] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            //The loop stops when reaching the A-row or if next square contains a friendly piece
            while(possibleMoves % 8 !== 0 && possibleMoves !== 0 && !friendlyPieces.includes(chessBoard[possibleMoves-1]))
            {
                //If the next square contains an enemy piece that square is being added to legalMoves,
                //and the loop stops
                if(enemyPieces.includes(chessBoard[possibleMoves-1]))
                {
                    possibleMoves--;
                    legalMoves.push(squareNames[possibleMoves]);
                    break;
                }
                possibleMoves--;
                legalMoves.push(squareNames[possibleMoves]);
            }
        }
        else
        {
            wouldBeCheck = false;
        }
        possibleMoves = chessBoard.indexOf(chosenPiece);
        checkStorage[possibleMoves] = chosenPiece;
        checkStorage[possibleMoves-1] = chessBoard[possibleMoves-1];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the ROOK can move DOWN. If it is >= 56 it is on the bottom line.
    if((chessBoard.indexOf(chosenPiece) < 56) && !friendlyPieces.includes(chessBoard[possibleMoves+8]))
    {
        checkStorage[possibleMoves] = "[]";
        checkStorage[possibleMoves+8] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            //The loop stops when reaching the 1-row or if next square contains a friendly piece
            while(possibleMoves+8 <= 63 && !friendlyPieces.includes(chessBoard[possibleMoves+8]))
            {
                //If the next square contains an enemy piece that square is being added to legalMoves,
                //and the loop stops
                if(enemyPieces.includes(chessBoard[possibleMoves+8]))
                {
                    possibleMoves+=8;
                    legalMoves.push(squareNames[possibleMoves]);
                    break;
                }
                possibleMoves+=8;
                legalMoves.push(squareNames[possibleMoves]);
            }
        }
        else
        {
            wouldBeCheck = false;
        }
        possibleMoves = chessBoard.indexOf(chosenPiece);
        checkStorage[possibleMoves] = chosenPiece;
        checkStorage[possibleMoves+8] = chessBoard[possibleMoves+8];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the ROOK can move UP. If it is <= 7 it is on the top line.
    if(chessBoard.indexOf(chosenPiece) > 7 && !friendlyPieces.includes(chessBoard[possibleMoves-8]))
    {
        checkStorage[possibleMoves] = "[]";
        checkStorage[possibleMoves-8] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            //The loop stops when reaching the 8-row or if next square contains a friendly piece
            while(possibleMoves-8 >= 0 && !friendlyPieces.includes(chessBoard[possibleMoves-8]))
            {
                //If the next square contains an enemy piece that square is being added to legalMoves,
                //and the loop stops
                if(enemyPieces.includes(chessBoard[possibleMoves-8]))
                {
                    possibleMoves-=8;
                    legalMoves.push(squareNames[possibleMoves]);
                    break;
                }
                possibleMoves-=8;
                legalMoves.push(squareNames[possibleMoves]);
            }
        }
        else
        {
            wouldBeCheck = false;
        }
        possibleMoves = chessBoard.indexOf(chosenPiece);
        checkStorage[possibleMoves] = chosenPiece;
        checkStorage[possibleMoves-8] = chessBoard[possibleMoves-8];
    } 
}

function KnightMovement()
{
    var possibleMoves = chessBoard.indexOf(chosenPiece);  
    
    //Checks if the KNIGHT can move 1 RIGHT and 2 UP
    if((possibleMoves+1) % 8 !== 0 && chessBoard.indexOf(chosenPiece) > 15 && !friendlyPieces.includes(chessBoard[possibleMoves-15]))
    {
        possibleMoves-=15;
    
        checkStorage[possibleMoves+15] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves+15] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the KNIGHT can move 2 RIGHT and 1 UP
    if((possibleMoves+1) % 8 !== 0 && (possibleMoves+2) % 8 !== 0 && chessBoard.indexOf(chosenPiece) > 7 && !friendlyPieces.includes(chessBoard[possibleMoves-6]))
    {
        possibleMoves-=6;
        
        checkStorage[possibleMoves+6] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves+6] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the KNIGHT can move 1 LEFT and 2 UP
    if(possibleMoves % 8 !== 0 && chessBoard.indexOf(chosenPiece) > 15 && !friendlyPieces.includes(chessBoard[possibleMoves-17]))
    {
        possibleMoves-=17;
        
        checkStorage[possibleMoves+17] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves+17] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the KNIGHT can move 2 LEFT and 1 UP
    if(possibleMoves % 8 !== 0 && (possibleMoves-1) % 8 !== 0 && chessBoard.indexOf(chosenPiece) > 7 && !friendlyPieces.includes(chessBoard[possibleMoves-10]))
    {
        possibleMoves-=10;
        
        checkStorage[possibleMoves+10] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves+10] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the KNIGHT can move 1 RIGHT and 2 DOWN
    if((possibleMoves+1) % 8 !== 0 && chessBoard.indexOf(chosenPiece) < 48 && !friendlyPieces.includes(chessBoard[possibleMoves+17]))
    {
        possibleMoves+=17;
        
        checkStorage[possibleMoves-17] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves-17] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the KNIGHT can move 2 RIGHT and 1 DOWN
    if((possibleMoves+1) % 8 !== 0 && (possibleMoves+2) % 8 !== 0 && chessBoard.indexOf(chosenPiece) < 56 && !friendlyPieces.includes(chessBoard[possibleMoves+10]))
    {
        possibleMoves+=10;
        
        checkStorage[possibleMoves-10] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves-10] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the KNIGHT can move 1 LEFT and 2 DOWN
    if(possibleMoves % 8 !== 0 && chessBoard.indexOf(chosenPiece) < 48 && !friendlyPieces.includes(chessBoard[possibleMoves+15]))//????
    {
        possibleMoves+=15;
        
        checkStorage[possibleMoves-15] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves-15] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the KNIGHT can move 2 LEFT and 1 DOWN
    if(possibleMoves % 8 !== 0 && (possibleMoves-1) % 8 !== 0 && chessBoard.indexOf(chosenPiece) < 56 && !friendlyPieces.includes(chessBoard[possibleMoves+6]))
    {
        possibleMoves+=6;
        
        checkStorage[possibleMoves-6] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves-6] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
}

function BishopMovement()
{
    var possibleMoves = chessBoard.indexOf(chosenPiece);  
    //Checks if the BISHOP can move UP-RIGHT. 
    //If the piece is not on the edge and there is no friendly piece UP-RIGHT
    if((possibleMoves+1) % 8 !== 0 && chessBoard.indexOf(chosenPiece) > 7 && !friendlyPieces.includes(chessBoard[possibleMoves-7]))
    {
        checkStorage[possibleMoves] = "[]";
        checkStorage[possibleMoves-7] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            //The loop stops when reaching the H-row or the 8-row or if the next square contains a friendly piece
            while((possibleMoves+1) % 8 !== 0 && possibleMoves-7 >= 0 && !friendlyPieces.includes(chessBoard[possibleMoves-7]))
            {
                if(enemyPieces.includes(chessBoard[possibleMoves-7]))
                {
                    possibleMoves-=7;
                    legalMoves.push(squareNames[possibleMoves]);
                    break;
                }
                possibleMoves-=7;
                legalMoves.push(squareNames[possibleMoves]);   
            }
        }
        else
        {
            wouldBeCheck = false;
        }
        possibleMoves = chessBoard.indexOf(chosenPiece);
        checkStorage[possibleMoves] = chosenPiece;
        checkStorage[possibleMoves-7] = chessBoard[possibleMoves-7];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the BISHOP can move UP-LEFT.
    //If the piece is not on the edge and there is no friendly piece UP-LEFT
    if(possibleMoves % 8 !== 0 && chessBoard.indexOf(chosenPiece) > 7 && !friendlyPieces.includes(chessBoard[possibleMoves-9]))
    {
        checkStorage[possibleMoves] = "[]";
        checkStorage[possibleMoves-9] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            //The loop stops when reaching the A-row or the 8-row or if the next square contains a friendly piece
            while(possibleMoves % 8 !== 0 && possibleMoves-9 >= 0 && !friendlyPieces.includes(chessBoard[possibleMoves-9]))
            {
                if(enemyPieces.includes(chessBoard[possibleMoves-9]))
                {
                    possibleMoves-=9;
                    legalMoves.push(squareNames[possibleMoves]);
                    break;
                }
                possibleMoves-=9;
                legalMoves.push(squareNames[possibleMoves]);   
            }
        }
        else
        {
            wouldBeCheck = false;
        }
        possibleMoves = chessBoard.indexOf(chosenPiece);
        checkStorage[possibleMoves] = chosenPiece;
        checkStorage[possibleMoves-9] = chessBoard[possibleMoves-9];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);
    
    //Checks if the BISHOP can move DOWN-RIGHT. 
    //If the piece is not on the edge and there is no friendly piece DOWN-RIGHT
    if((possibleMoves+1) % 8 !== 0 && chessBoard.indexOf(chosenPiece) < 56 && !friendlyPieces.includes(chessBoard[possibleMoves+9]))
    {
        checkStorage[possibleMoves] = "[]";
        checkStorage[possibleMoves+9] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            //The loop stops when reaching the H-row or the 1-row or if the next square contains a friendly piece
            while((possibleMoves+1) % 8 !== 0 && possibleMoves+9 <= 63 && !friendlyPieces.includes(chessBoard[possibleMoves+9]))
            {
                if(enemyPieces.includes(chessBoard[possibleMoves+9]))
                {
                    possibleMoves+=9;
                    legalMoves.push(squareNames[possibleMoves]);
                    break;
                }
                possibleMoves+=9;
                legalMoves.push(squareNames[possibleMoves]);   
            }
        }
        else
        {
            wouldBeCheck = false;
        }
        possibleMoves = chessBoard.indexOf(chosenPiece);
        checkStorage[possibleMoves] = chosenPiece;
        checkStorage[possibleMoves+9] = chessBoard[possibleMoves+9];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the BISHOP can move DOWN-LEFT.
    //If the piece is not on the edge and there is no friendly piece DOWN-LEFT
    if(possibleMoves % 8 !== 0 && chessBoard.indexOf(chosenPiece) < 56 && !friendlyPieces.includes(chessBoard[possibleMoves+7]))
    {
        checkStorage[possibleMoves] = "[]";
        checkStorage[possibleMoves+7] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            //The loop stops when reaching the A-row or the 1-row or if the next square contains a friendly piece
            while(possibleMoves % 8 !== 0 && possibleMoves+7 <= 63 && !friendlyPieces.includes(chessBoard[possibleMoves+7]))
            {
                if(enemyPieces.includes(chessBoard[possibleMoves+7]))
                {
                    possibleMoves+=7;
                    legalMoves.push(squareNames[possibleMoves]);
                    break;
                }
                possibleMoves+=7;
                legalMoves.push(squareNames[possibleMoves]);   
            }
        }
        else
        {
            wouldBeCheck = false;
        }
        possibleMoves = chessBoard.indexOf(chosenPiece);
        checkStorage[possibleMoves] = chosenPiece;
        checkStorage[possibleMoves+7] = chessBoard[possibleMoves+7];
    }
}

function QueenMovement()
{
    //Since the queen can move as both the rook and the bishop, those functions are called
    RookMovement();
    BishopMovement();
}

function KingMovement()
{
    var possibleMoves = chessBoard.indexOf(chosenPiece);    
    //Checks if the KING can move to the RIGHT (if it's not on the H-row or next to a friendly piece)
    if((possibleMoves + 1) % 8 !== 0 && !friendlyPieces.includes(chessBoard[possibleMoves+1]))
    {
        possibleMoves++;
        
        checkStorage[possibleMoves-1] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves-1] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the KING can move to the LEFT (if it's not on the A-row or next to a friendly piece)
    //Since 0 isn't devisible by 0 we also have to check if it is on A1 (index 0)
    if(possibleMoves % 8 !== 0 && possibleMoves !== 0 && !friendlyPieces.includes(chessBoard[possibleMoves-1]))
    {
        possibleMoves--;
        
        checkStorage[possibleMoves+1] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves+1] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the KING can move DOWN. If it is >= 56 it is on the bottom line.
    if((chessBoard.indexOf(chosenPiece) < 56) && !friendlyPieces.includes(chessBoard[possibleMoves+8]))
    {
        possibleMoves+=8;
        
        checkStorage[possibleMoves-8] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves-8] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the KING can move UP. If it is <= 7 it is on the bottom line.
    if(chessBoard.indexOf(chosenPiece) > 7 && !friendlyPieces.includes(chessBoard[possibleMoves-8]))
    {
        possibleMoves-=8;
        
        checkStorage[possibleMoves+8] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves+8] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    } 
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the KING can move UP-RIGHT. 
    //If the piece is not on the edge and there is no friendly piece UP-RIGHT
    if((possibleMoves+1) % 8 !== 0 && chessBoard.indexOf(chosenPiece) > 7 && !friendlyPieces.includes(chessBoard[possibleMoves-7]))
    {
        possibleMoves-=7;
        
        checkStorage[possibleMoves+7] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves+7] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the KING can move UP-LEFT.
    //If the piece is not on the edge and there is no friendly piece UP-LEFT
    if(possibleMoves % 8 !== 0 && chessBoard.indexOf(chosenPiece) > 7 && !friendlyPieces.includes(chessBoard[possibleMoves-9]))
    {
        possibleMoves-=9;
        
        checkStorage[possibleMoves+9] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves+9] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);
    
    //Checks if the KING can move DOWN-RIGHT. 
    //If the piece is not on the edge and there is no friendly piece DOWN-RIGHT
    if((possibleMoves+1) % 8 !== 0 && chessBoard.indexOf(chosenPiece) < 56 && !friendlyPieces.includes(chessBoard[possibleMoves+9]))
    {
        possibleMoves+=9;
        
        checkStorage[possibleMoves-9] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves-9] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
    possibleMoves = chessBoard.indexOf(chosenPiece);

    //Checks if the KING can move DOWN-LEFT.
    //If the piece is not on the edge and there is no friendly piece DOWN-LEFT
    if(possibleMoves % 8 !== 0 && chessBoard.indexOf(chosenPiece) < 56 && !friendlyPieces.includes(chessBoard[possibleMoves+7]))
    {
        possibleMoves+=7;
        
        checkStorage[possibleMoves-7] = "[]";
        checkStorage[possibleMoves] = chosenPiece;
        EnemyCheckChecker();  
        
        if(!wouldBeCheck)
        {
            legalMoves.push(squareNames[possibleMoves]);
        }
        else
        {
            wouldBeCheck = false;
        }
        checkStorage[possibleMoves-7] = chosenPiece;
        checkStorage[possibleMoves] = chessBoard[possibleMoves];
    }
}

    //CHECK FUNCTIONS//
//If isCheck, this function checks if any piece can be moved
function MateChecker()
{
    //Is turned true so ResetEnPassant() or LegalMoves() are not runned in MovementManager()
    checkingForMate = true;
    //Goes through all friendly pieces to see if any can make a move
    for(iM = 0; iM < friendlyPieces.length; iM++)
    {
        chosenPiece = friendlyPieces[iM];
        MovementManager();
        isCheck = true;
    }
    checkingForMate = false;

    if(legalMoves.length === 0)
    {
        isMate = true;
    }
    //Clears legalMoves 
    legalMoves.splice(0); 
}

//Checks if any enemy piece can take or would be able to take the king
function EnemyCheckChecker()
{
    //Clears checkSquares so it's empty when running CheckManager()
    checkSquares.splice(0);
    //Checks if any enemy pieces can take the king
    for(iE = 0; iE < enemyPieces.length; iE++)
    {
        kingSlayer = enemyPieces[iE];
        CheckManager();
    }

    if(isCheckingForCheck)
    {   //If the program is checking if a player is in check this happens
        if(checkSquares.includes(squareNames[checkStorage.indexOf("ki")]) || checkSquares.includes(squareNames[checkStorage.indexOf("KI")]))
        {
            isCheck = true;
        }
        else
        {
            isCheck = false;
        }
    }
    else
    {   //If the program checks if a player would be in check if making a move this happens
        if(checkSquares.includes(squareNames[checkStorage.indexOf("ki")]) || checkSquares.includes(squareNames[checkStorage.indexOf("KI")]))
        {
            wouldBeCheck = true;
        }
    }
}

//The following functions is for checking if any enemy pawns would make or is making the friendly the player check
function CheckManager()
{
    if(kingSlayer.includes("p") || kingSlayer.includes("P") )
    {
        PawnChecker();
    }
    else if(kingSlayer.includes("r") || kingSlayer.includes("R"))
    {
        RookChecker();
    }
    else if(kingSlayer.includes("n") || kingSlayer.includes("N"))
    {
        KnightChecker();
    }
    else if(kingSlayer.includes("b") || kingSlayer.includes("B"))
    {
        BishopChecker();
    }
    else if(kingSlayer.includes("k")|| kingSlayer.includes("K"))
    {
        KingChecker();
    }
    else if(kingSlayer.includes("q") || kingSlayer.includes("Q"))
    {
        QueenChecker();
    }    
}

//These functions are almost the same as the movement functions
//chosenPiece->kingSlayer, possibleMoves->possibleEnemyMoves, blackPieces->whitePieces, whitePieces->blackPieces, friendlyPieces->enemyPieces, enemyPieces->friendlyPieces
//Controls the pawn movement.
//Depending on wich players turn it is, there will be a different equation.
function PawnChecker()
{
    var possibleEnemyMoves = checkStorage.indexOf(kingSlayer);
    
    if(isWhiteTurn)
    {    
        //If the chosen pawn isn't on the A-row, which all is devisble by 8, the square should be added to the legalMoves array
        if((possibleEnemyMoves) % 8 !== 0 && !blackPieces.includes(checkStorage[possibleEnemyMoves+7]))
        {
            checkSquares.push(squareNames[possibleEnemyMoves+7]);
        }  
    
        //If the chosen pawn isn't on the A-row, which all is devisble by 8, the square should be added to the legalMoves array
        if((possibleEnemyMoves+1) % 8 !== 0 && !blackPieces.includes(checkStorage[possibleEnemyMoves+9]))
        {
            checkSquares.push(squareNames[possibleEnemyMoves+9]);
        }  
    }
    else //Black
    {
       //If the chosen pawn isn't on the H-row, which all +1 is devisble by 8, the square should be added to the legalMoves array
       if((possibleEnemyMoves + 1) % 8 !== 0 && !whitePieces.includes(checkStorage[possibleEnemyMoves-7]))
        {
            checkSquares.push(squareNames[possibleEnemyMoves-7]);
        }  
    
        //If the chosen pawn isn't on the A-row, which all is devisble by 8, the square should be added to the legalMoves array
        if((possibleEnemyMoves) % 8 !== 0 && !whitePieces.includes(checkStorage[possibleEnemyMoves-9]))
        {
            checkSquares.push(squareNames[possibleEnemyMoves-9]);
        } 
    }
}

function RookChecker()
{
    var possibleEnemyMoves = checkStorage.indexOf(kingSlayer);   
    
    //Checks if the ROOK can move to the RIGHT
    if((possibleEnemyMoves + 1) % 8 !== 0 && !enemyPieces.includes(checkStorage[possibleEnemyMoves+1]))
    {
        while((possibleEnemyMoves + 1) % 8 !== 0 && !enemyPieces.includes(checkStorage[possibleEnemyMoves+1]))
        {
            if(friendlyPieces.includes(checkStorage[possibleEnemyMoves+1]))
            {
                possibleEnemyMoves++;
                checkSquares.push(squareNames[possibleEnemyMoves]);
                break;
            }
            possibleEnemyMoves++;
            checkSquares.push(squareNames[possibleEnemyMoves]);
        }                                                                                     
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the ROOK can move to the LEFT
    if(possibleEnemyMoves % 8 !== 0 && possibleEnemyMoves !== 0 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-1]))
    {
        while(possibleEnemyMoves % 8 !== 0 && possibleEnemyMoves !== 0 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-1]))
        {
            if(friendlyPieces.includes(checkStorage[possibleEnemyMoves-1]))
            {
                possibleEnemyMoves--;
                checkSquares.push(squareNames[possibleEnemyMoves]);
                break;
            }
            possibleEnemyMoves--;
            checkSquares.push(squareNames[possibleEnemyMoves]);
        }
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the ROOK can move DOWN. If it is >= 56 it is on the bottom line.
    if((checkStorage.indexOf(kingSlayer) < 56) && !enemyPieces.includes(checkStorage[possibleEnemyMoves+8]))
    {
        while(possibleEnemyMoves+8 <= 63 && !enemyPieces.includes(checkStorage[possibleEnemyMoves+8]))
        {
            if(friendlyPieces.includes(checkStorage[possibleEnemyMoves+8]))
            {
                possibleEnemyMoves+=8;
                checkSquares.push(squareNames[possibleEnemyMoves]);
                break;
            }
            possibleEnemyMoves+=8;
            checkSquares.push(squareNames[possibleEnemyMoves]);
        }
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the ROOK can move UP. If it is <= 7 it is on the bottom line.
    if(checkStorage.indexOf(kingSlayer) > 7 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-8]))
    {
        while(possibleEnemyMoves-8 >= 0 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-8]))
        {
            if(friendlyPieces.includes(checkStorage[possibleEnemyMoves-8]))
            {
                possibleEnemyMoves-=8;
                checkSquares.push(squareNames[possibleEnemyMoves]);
                break;
            }
            possibleEnemyMoves-=8;
            checkSquares.push(squareNames[possibleEnemyMoves]);
        } 
    } 
}

function KnightChecker()
{
    var possibleEnemyMoves = checkStorage.indexOf(kingSlayer); 

    //Checks if the KNIGHT can move 1 RIGHT and 2 UP
    if((possibleEnemyMoves+1) % 8 !== 0 && checkStorage.indexOf(kingSlayer) > 15 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-15]))
    {
        possibleEnemyMoves-=15;
        checkSquares.push(squareNames[possibleEnemyMoves]);
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the KNIGHT can move 2 RIGHT and 1 UP
    if((possibleEnemyMoves+1) % 8 !== 0 && (possibleEnemyMoves+2) % 8 !== 0 && checkStorage.indexOf(kingSlayer) > 7 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-6]))
    {
        possibleEnemyMoves-=6;
        checkSquares.push(squareNames[possibleEnemyMoves]);
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the KNIGHT can move 1 LEFT and 2 UP
    if(possibleEnemyMoves % 8 !== 0 && checkStorage.indexOf(kingSlayer) > 15 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-17]))
    {
        possibleEnemyMoves-=17;
        checkSquares.push(squareNames[possibleEnemyMoves]);
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the KNIGHT can move 2 LEFT and 1 UP
    if(possibleEnemyMoves % 8 !== 0 && (possibleEnemyMoves-1) % 8 !== 0 && checkStorage.indexOf(kingSlayer) > 7 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-10]))
    {
        possibleEnemyMoves-=10;
        checkSquares.push(squareNames[possibleEnemyMoves]);
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the KNIGHT can move 1 RIGHT and 2 DOWN
    if((possibleEnemyMoves+1) % 8 !== 0 && checkStorage.indexOf(kingSlayer) < 48 && !enemyPieces.includes(checkStorage[possibleEnemyMoves+17]))
    {
        possibleEnemyMoves+=17;
        checkSquares.push(squareNames[possibleEnemyMoves]);
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the KNIGHT can move 2 RIGHT and 1 DOWN
    if((possibleEnemyMoves+1) % 8 !== 0 && (possibleEnemyMoves+2) % 8 !== 0 && checkStorage.indexOf(kingSlayer) < 56 && !enemyPieces.includes(checkStorage[possibleEnemyMoves+10]))
    {
        possibleEnemyMoves+=10;
        checkSquares.push(squareNames[possibleEnemyMoves]);
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the KNIGHT can move 1 LEFT and 2 DOWN
    if(possibleEnemyMoves % 8 !== 0 && checkStorage.indexOf(kingSlayer) < 48 && !enemyPieces.includes(checkStorage[possibleEnemyMoves+15]))
    {
        possibleEnemyMoves+=15;
        checkSquares.push(squareNames[possibleEnemyMoves]);
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the KNIGHT can move 2 LEFT and 1 DOWN
    if(possibleEnemyMoves % 8 !== 0 && (possibleEnemyMoves-1) % 8 !== 0 && checkStorage.indexOf(kingSlayer) < 56 && !enemyPieces.includes(checkStorage[possibleEnemyMoves+6]))
    {
        possibleEnemyMoves+=6;
        checkSquares.push(squareNames[possibleEnemyMoves]);
    }
}

function BishopChecker()
{
    var possibleEnemyMoves = checkStorage.indexOf(kingSlayer); 
    //Checks if the BISHOP can move UP-RIGHT. 
    //If the piece is not on the edge and there is no friendly piece UP-RIGHT
    if((possibleEnemyMoves+1) % 8 !== 0 && checkStorage.indexOf(kingSlayer) > 7 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-7]))
    {
        while((possibleEnemyMoves+1) % 8 !== 0 && possibleEnemyMoves-7 >= 0 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-7]))
        {
            if(friendlyPieces.includes(checkStorage[possibleEnemyMoves-7]))
            {
                possibleEnemyMoves-=7;
                checkSquares.push(squareNames[possibleEnemyMoves]);
                break;
            }
            possibleEnemyMoves-=7;
            checkSquares.push(squareNames[possibleEnemyMoves]);   
        }
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the BISHOP can move UP-LEFT.
    //If the piece is not on the edge and there is no friendly piece UP-LEFT
    if(possibleEnemyMoves % 8 !== 0 && checkStorage.indexOf(kingSlayer) > 7 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-9]))
    {
        while(possibleEnemyMoves % 8 !== 0 && possibleEnemyMoves-9 >= 0 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-9]))
        {
            if(friendlyPieces.includes(checkStorage[possibleEnemyMoves-9]))
            {
                possibleEnemyMoves-=9;
                checkSquares.push(squareNames[possibleEnemyMoves]);
                break;
            }
            possibleEnemyMoves-=9;
            checkSquares.push(squareNames[possibleEnemyMoves]);   
        }
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);
    
    //Checks if the BISHOP can move DOWN-RIGHT. 
    //If the piece is not on the edge and there is no friendly piece DOWN-RIGHT
    if((possibleEnemyMoves+1) % 8 !== 0 && checkStorage.indexOf(kingSlayer) < 56 && !enemyPieces.includes(checkStorage[possibleEnemyMoves+9]))
    {
        while((possibleEnemyMoves+1) % 8 !== 0 && possibleEnemyMoves+9 <= 63 && !enemyPieces.includes(checkStorage[possibleEnemyMoves+9]))
        {
            if(friendlyPieces.includes(checkStorage[possibleEnemyMoves+9]))
            {
                possibleEnemyMoves+=9;
                checkSquares.push(squareNames[possibleEnemyMoves]);
                break;
            }
            possibleEnemyMoves+=9;
            checkSquares.push(squareNames[possibleEnemyMoves]);   
        }
    }
    var possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the BISHOP can move DOWN-LEFT.
    //If the piece is not on the edge and there is no friendly piece DOWN-LEFT
    if(possibleEnemyMoves % 8 !== 0 && checkStorage.indexOf(kingSlayer) < 56 && !enemyPieces.includes(checkStorage[possibleEnemyMoves+7]))
    {
        while(possibleEnemyMoves % 8 !== 0 && possibleEnemyMoves+7 <= 63 && !enemyPieces.includes(checkStorage[possibleEnemyMoves+7]))
        {
            if(friendlyPieces.includes(checkStorage[possibleEnemyMoves+7]))
            {
                possibleEnemyMoves+=7;
                checkSquares.push(squareNames[possibleEnemyMoves]);
                break;
            }
            possibleEnemyMoves+=7;
            checkSquares.push(squareNames[possibleEnemyMoves]);   
        }
    }
}

function QueenChecker()
{
    checkSquares.push("Queen");
    RookChecker();
    BishopChecker();
}

function KingChecker()
{
    var possibleEnemyMoves = checkStorage.indexOf(kingSlayer);
    checkSquares.push("King");    
    //Checks if the KING can move to the RIGHT
    if((possibleEnemyMoves + 1) % 8 !== 0 && !enemyPieces.includes(checkStorage[possibleEnemyMoves+1]))
    {
        possibleEnemyMoves++;
        checkSquares.push(squareNames[possibleEnemyMoves]);                                                                                     
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the KING can move to the LEFT
    if(possibleEnemyMoves % 8 !== 0 && possibleEnemyMoves !== 0 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-1]))
    {
        possibleEnemyMoves--;
        checkSquares.push(squareNames[possibleEnemyMoves]);
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the KING can move DOWN. If it is >= 56 it is on the bottom line.
    if((checkStorage.indexOf(kingSlayer) < 56) && !enemyPieces.includes(checkStorage[possibleEnemyMoves+8]))
    {
        possibleEnemyMoves+=8;
        checkSquares.push(squareNames[possibleEnemyMoves]);
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);
    //Checks if the KING can move UP. If it is <= 7 it is on the bottom line.
    if(checkStorage.indexOf(kingSlayer) > 7 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-8]))
    {
        possibleEnemyMoves-=8;
        checkSquares.push(squareNames[possibleEnemyMoves]);
    } 
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the KING can move UP-RIGHT. 
    //If the piece is not on the edge and there is no friendly piece UP-RIGHT
    if((possibleEnemyMoves+1) % 8 !== 0 && checkStorage.indexOf(kingSlayer) > 7 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-7]))
    {
        possibleEnemyMoves-=7;
        checkSquares.push(squareNames[possibleEnemyMoves]);   
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the KING can move UP-LEFT.
    //If the piece is not on the edge and there is no friendly piece UP-LEFT
    if(possibleEnemyMoves % 8 !== 0 && checkStorage.indexOf(kingSlayer) > 7 && !enemyPieces.includes(checkStorage[possibleEnemyMoves-9]))
    {
        possibleEnemyMoves-=9;
        checkSquares.push(squareNames[possibleEnemyMoves]);  
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);
    
    //Checks if the KING can move DOWN-RIGHT. 
    //If the piece is not on the edge and there is no friendly piece DOWN-RIGHT
    if((possibleEnemyMoves+1) % 8 !== 0 && checkStorage.indexOf(kingSlayer) < 56 && !enemyPieces.includes(checkStorage[possibleEnemyMoves+9]))
    {
        possibleEnemyMoves+=9;
        checkSquares.push(squareNames[possibleEnemyMoves]);
    }
    possibleEnemyMoves = checkStorage.indexOf(kingSlayer);

    //Checks if the KING can move DOWN-LEFT.
    //If the piece is not on the edge and there is no friendly piece DOWN-LEFT
    if(possibleEnemyMoves % 8 !== 0 && checkStorage.indexOf(kingSlayer) < 56 && !enemyPieces.includes(checkStorage[possibleEnemyMoves+7]))
    {
        possibleEnemyMoves+=7;
        checkSquares.push(squareNames[possibleEnemyMoves]);
    }
}

//If check mate everything is reseted and a restart button appears
function GameOver()
{
    restartButton.style.display = "block";
    squareButton.style.display = "none";
    output.style.display = "none";
    isCheck = false;
    isWhiteTurn = true;
    isCastlingBr1 = false;
    isCastlingBr2 = false;
    isCastlingWr1 = false;
    isCastlingWr2 = false;
    checkingForMate = false;
    startGame = false;
    
    chessBoard = [
    "R1", "N1", "B1", "Q1", "KI", "B2", "N2", "R2",
    "P1", "P2", "P3", "P4", "P5", "P6", "P7", "P8",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8",
    "r1", "n1", "b1", "q1", "ki", "b2", "n2", "r2"
    ];

    checkStorage = [
    "R1", "N1", "B1", "Q1", "KI", "B2", "N2", "R2",
    "P1", "P2", "P3", "P4", "P5", "P6", "P7", "P8",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "[]", "[]", "[]", "[]", "[]", "[]", "[]", "[]",
    "p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8",
    "r1", "n1", "b1", "q1", "ki", "b2", "n2", "r2"
    ];

    unmovedPawns = ["p1", "p2", "p3", "p4", "p5","p6", "p7", "p8", "P1", "P2", "P3", "P4", "P5", "P6", "P7", "P8"];
    unmovedCastling = ["ki", "r1", "r2", "KI", "R1", "R2"];

    whitePieces = ["p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "r1", "r2", "b1", "b2", "n1", "n2", "q1", "ki"];
    blackPieces = ["P1", "P2", "P3", "P4", "P5", "P6", "P7", "P8", "R1", "R2", "B1", "B2", "N1", "N2", "Q1", "KI"];

    checkSquares.splice(0);
    legalMoves.splice(0);
}
</script>